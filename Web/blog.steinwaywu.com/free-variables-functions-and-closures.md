# 自由変数、関数、そしてクロージャ

(元記事は http://blog.steinwaywu.com/free-variables-functions-and-closures/ です)

(これはボストン大学 CS320 コース用の記事です)

環境、クロージャ、関数について議論するために、はじめに自由変数と束縛変数について議論しようと思います。

## 自由変数と束縛変数

次の例を見てみましょう。

```ats
lam (x) => x + y
```

ここでは上記の `x`, `x`, `y` を (`x` と `y` の) **出現 (occurrence)**と呼びます。
最初の `x` は `x` の**束縛する出現 (binding occurrence)**と呼ばれ、二番目の `x` は**束縛される出現 (bound occurrence)**と呼ばれ、そして `y` は**自由な出現 (free occurrence)**です。

引数リスト中の `x` はプレースホルダーのための名前を宣言していて、本体中の `x` はプレースホルダーになります。
そのような無名関数がパラメータと共に呼び出されると、全てのプレースホルダー `x` は実際のパラメータ値で置換 (もしくは束縛) されます。
けれども、`y` が引数リスト中で定義されていないので、それはプレースホルダーとして扱われません。
この無名関数を呼び出しても、`y` は具体的な値を持っていません。
それは束縛されておらず、自由なのです。

```ats
fun add (x:int, y:int): int = x + y
```

ここでは、本体中の全ての変数の出現は束縛されています。
引数リスト中のそれらの出現は束縛する出現なのです。

```ats
fun addclo (x:int):<cloref1> int = x + y
```

ここでは、本体中の `y` は自由な出現です。

## 環境と評価

評価器がプログラムを評価するとき、変数の値を知る必要があります。
パラメータ `123` を共なって `addclo` を呼び出すことを考えてみましょう。

1. 評価器が `x` の束縛する出現を見つけると、`123` を `x` に束縛します。これは実際には環境にキーバリューペア `(x,123)` を置くのと同じです。
2. 評価器は本体を評価します。それが `x` の束縛される出現を見つけると、環境を探してそれを `123` で置き換えます。
3. 評価器が `y` の自由な出現を見つけるか、もしくは現在の環境に `y` の束縛が見つからない場合、それは次のような動作をします。
    * それはエラーを発生させるか評価を停止します。
    * もしくは (この関数の外で `y` が定義されていれば) 親のスコープで `y` を探します。

自由変数はローカルに出現するかもしれませんが、正しいプログラムでは全ての変数は最終的に束縛されなければなりません。

## 関数とクロージャ

関数では全てのローカル変数は束縛されなければなりません。
これは全ての変数は (引数リストか本体中に) 束縛する出現を持ち、場合によって数個の束縛される出現を持つことを意味しています。

クロージャは実際には関数**と環境**です。
評価器がはじめにクロージャの定義を見つけたときに、現在の環境は評価器によって記録されます。
後に評価器がクロージャの適用の評価を開始すると、それは元の環境を読み出し、その環境の元でクロージャ適用を評価します。
環境が必要なのには理由があります。

クロージャの定義では、変数は (その定義のスコープにおいて) 束縛されている必要はありません。
しかしそれは評価されるために別の場所で束縛されていなければなりません。
次のコードを見てみましょう。

```ats
implement main0 () = let
    val y = 1
    fun addclo (x:int):<cloref1> int = x + y
    val z = addclo(123)
in
    ()
end
```

ここでは、評価器がメインの定義を見つけると次のように動作します:

1. `1` を `y` に束縛します。(つまり `(y,1)` を環境に置きます)
2. `addclo` の定義を記録します。これはつまり関数と環境のペアをテーブルに置くことです。環境は `(y,1)` を含みます。
3. 評価器はクロージャ適用を見つけます。
    1. テーブルから `(addclo, env)` を読み出します。
    2. `x` は束縛変数です。それは引数リスト中の束縛する出現なので、`123` に束縛されています。
    3. `env` **に従って** `y` **は** `1` **に束縛されます。** `env` **は** `addclo` **を定義した時の環境です。**
    4. 123 + 1 である `124` を返し、それは `z` に束縛します。
4. ...

予想される通り、クロージャにその環境が付随しないと、`y` の値を知ることはできません。
けれども、関数においては全ての変数は束縛されているので、環境が付随する必要はありません。
