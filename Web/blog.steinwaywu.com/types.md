# 型について

(元記事は http://blog.steinwaywu.com/types/ です)

(これはボストン大学 CS320 コース用の記事です)

型は共通の特性を持つモノの分類です。
私達の文脈では、一般に以下を決定するようなデータの様々な型を同定する**分類**です ([参考](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B))。

* その型の**取り得る値**
* その型の値に対して行なえる操作
* そのデータの意味
* その型の値を保管する方法

もしくは値の空間、つまり取り得る全ての値の集合として型を考えることもできます。

* 整数型: `{... -2, -1, 0, 1, 2, ...}`
* 真理値型: `{true, false}`
* 文字型: `{a, b, c, ...}`

## プリミティブ型/複合型

一般に `int`, `bool`, `string`, `float` などをプリミティブ型と呼びます。
それらは複合型の構成要素です。
複合型は他の型を結び付けて作られた型です。

## 代数的データ型

代数的データ型は複合型の一種です。
その複合した型で値の空間がどのように決定されるかによって、**直積型**と**直和型**があります ([参考](https://ja.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B))。

### 直積型

もし P が A と B で作られた直積型なら、P の値の空間は A と B の値の空間の**デカルト積**になります。

型 `(bool, int)` のペアがあるとすると、それは `{..., (T -1), (F -1), (T 0), (F 0), (T 1), (F 1), ...}` となるような値の空間になります。
これは単純に `{T, F}` と `{..., -1, 0, 1, ...}` のデカルト積であると考えることができます。

これらの複合した型は一般に**フィールド**と呼ばれます。
上記の型は2つのフィールドを含んでいます。1番目は bool フィールド。2番目は int フィールドです。
フィールドは名前やラベルを持つことも、持たないこともあります。

直積型の例はペア、トリプル、レコードなどです。

### 直和型

もし S が A と B の直和型なら、S の値の空間は A と B の値の空間の**合併**になります。

直和型において、それぞれの複合した型は**バリアント**と呼ばれ、それぞれのバリアントは**コンストラクタ**で識別されます。
コンストラクタは型の**データを保持する**ことも、持たないこともあります。

次の `intlist` 型があるとします:

```ats
datatype intlist = 
    | list_cons of (int, intlist)
    | list_nil of ()
```

この整数リスト型は、2つのコンストラクタ `list_cons` と `list_nil` で識別される 2つのバリアントを持っています。

* `list_cons` 全ての空でない整数リストの集合に対応するバリアント
* `list_nil` 空の整数リストの集合に対応するバリアント

そしてまた、`list_cons` は2つのデータを保持しています。
それらは (リストノードの先頭を表わす) 1つの整数と (そのリストの残りを表わす) 1つの整数リストです。
しかし `list_nil` は何も保持していません。

## 型の値を定義する

プリミティブ型と直積型について、(その値の集合の要素である) その型のリテラル値を書いてみましょう。

```ats
val x = 3
val y = true
val z1 = (x, y)  // an unboxed/flat tuple
val z2 = '(x, y) // a boxed tuple

typedef point = @{x = double, y = double} // an unboxed record
val p = @{x = 0.0, y = 0.0 } : point

typedef student = `{name = string, id = int} // a boxed record
```

直和型については、その代わりに**コンストラクタを使います**。

```ats
val l = list_nil ()
val ls = list_cons (1, list_nil ())

// 1 -> (2 -> (3 -> nil))
val lss = list_cons (1, list_cons (2, list_cons (3, list_nil ()))
```

直和型の値をコンストラクトしたら、コンストラクタに配置したデータをを**取り出す**ために**パターンマッチ**を使うことができます。

```ats
case+ lss of
    | list_nil => println! ("Empty list!")
    | list_cons (x, y) => println! (x)
```

コンストラクタは直和型の異なるバリアントを識別できるので、その代数的データ型を解釈したり、その中のデータを得るためにコンストラクトしたプロセスを巻き戻したりするためにパターンマッチを使えるのです。
ここでは、`x` はそのリストの先頭である `1` にマッチします。
`y` はそのリストの残りである `list_cons (2, list_cons (3, list_nil ()))` にマッチします。

けれども、これは単なる整数のリストです。
それは他の型のデータを保持できません。
後で多相型を使うとこの問題を解決できるでしょう。
